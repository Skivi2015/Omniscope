"""
Bootstrap to materialize the repo. Firebase-ready.
Run:
  python repo_pack.py --init
Then locally:
  uvicorn server:app --reload --port 8080
Cloud Run:
  docker build -t omniscope:latest . && docker run -p 8080:8080 omniscope
Firebase:
  cd functions && npm i && npm run build
  firebase emulators:start
"""
from __future__ import annotations
import argparse
from pathlib import Path

FILES = {
    "README.md": r'''\nOmniScope Agents\n================\n\nPurpose\n-------\nModular agent framework with tool registry, hot-reloadable skills, UCB1 exploration, retries, circuit breaker, multiprocessing, and a FastAPI server. Firebase wrapper provided.\n\nQuick start\n-----------\npython -m venv .venv && source .venv/bin/activate\npip install -r requirements.txt\npython repo_pack.py --init\nuvicorn server:app --reload --port 8080\n\nCloud Run\n---------\nexport PROJECT_ID=your-project\ngcloud builds submit --tag gcr.io/$PROJECT_ID/omniscope\ngcloud run deploy omniscope --image gcr.io/$PROJECT_ID/omniscope --platform managed --allow-unauthenticated\n\nFirebase\n--------\ncd functions && npm i && npm run build\nSet env: firebase functions:config:set run.url="https://<cloud-run-url>"\nfirebase deploy --only functions,hosting\n\nPyPI Release\n------------\nOn GitHub Release "published", CI builds the package and publishes to PyPI using Trusted Publishing. See .github/workflows/pypi-publish.yml.\n''',

    "requirements.txt": r'''\nfastapi\nuvicorn[standard]\nPyYAML\n''',

    # Config\n    "bots.yaml": r'''\nbots:\n  seomi:\n    description: "SEO content helper"\n    skills_path: "skills/default.yaml"\n  soshie:\n    description: "Social media helper"\n    skills_path: "skills/default.yaml"\n  scouty:\n    description: "Ops helper"\n    skills_path: "skills/default.yaml"\n''',

    "skills/default.yaml": r'''\nrules:\n  - name: http_get\n    if_contains: ["http", "https", "fetch", "download"]\n    prefer_tool: http\n    params:\n      method: "GET"\n      timeout: 10\n  - name: run_python\n    if_contains: ["python", "compute", "code"]\n    prefer_tool: python\n    params:\n      timeout: 3\n  - name: json_transform\n    if_contains: ["json", "parse", "transform"]\n    prefer_tool: json\n  - name: math_expr\n    if_contains: ["math", "calc"]\n    prefer_tool: math\n''',

    # Python sources\n    "agent.py": r'''\nfrom __future__ import annotations\nimport re\nimport time\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom memory import Memory\nfrom tools import ToolRegistry, ToolError\nfrom upgrade import SkillsReloader\nfrom learning import UCB1\nfrom health import CircuitBreaker\n\nclass Agent:\n    """Adaptive agent with hot-reloaded skills and bandit tool selection."""\n\n    def __init__(\n        self,\n        name: str,\n        memory: Memory,\n        tools: ToolRegistry,\n        skills: SkillsReloader,\n        max_steps: int = 8,\n        retries: int = 2,\n    ) -> None:\n        self.name = name\n        self.memory = memory\n        self.tools = tools\n        self.skills = skills\n        self.max_steps = max_steps\n        self.retries = retries\n        self.bandit = UCB1()\n        self.breakers: Dict[str, CircuitBreaker] = {}\n\n    def _breaker(self, tool: str) -> CircuitBreaker:\n        if tool not in self.breakers:\n            self.breakers[tool] = CircuitBreaker()\n        return self.breakers[tool]\n\n    def plan(self, task: str) -> List[str]:\n        parts = re.split(r"[.;\n]", task)\n        steps = [p.strip() for p in parts if p.strip()]\n        return steps or [task]\n\n    def route(self, step: str) -> Tuple[str, Dict[str, Any]]:\n        self.skills.refresh()\n        rule = self.skills.match(step)\n        if rule:\n            return rule["prefer_tool"], rule.get("params", {})\n        s = step.lower()\n        if any(k in s for k in ("http://", "https://", "fetch")):\n            return "http", {"method": "GET"}\n        if any(k in s for k in ("python", "compute", "code")):\n            return "python", {}\n        if "json" in s:\n            return "json", {}\n        return "python", {}\n\n    def solve(self, task: str) -> Dict[str, Any]:\n        steps = self.plan(task)\n        transcript: List[Dict[str, Any]] = []\n        last_output: Any = None\n        for step in steps[: self.max_steps]:\n            tool_name, params = self.route(step)\n            if self._breaker(tool_name).open:\n                transcript.append({"step": step, "tool": tool_name, "skipped": True, "reason": "circuit_open"})\n                continue\n            weight = self.bandit.choose(tool_name)\n            success = False\n            error: Optional[str] = None\n            out: Any = None\n            for attempt in range(self.retries + 1):\n                try:\n                    out = self.tools.use(tool_name, step, context=last_output, **params)\n                    success = True\n                    break\n                except ToolError as e:\n                    error = str(e)\n                    time.sleep(0.2 * (attempt + 1))\n            self.bandit.update(tool_name, success)\n            self._breaker(tool_name).record(success)\n            rec = {"step": step, "tool": tool_name, "success": success, "weight": weight}\n            if success:\n                rec["output"] = out\n                last_output = out\n            else:\n                rec["error"] = error\n            transcript.append(rec)\n            self.memory.store(task=task, step=step, tool=tool_name, success=success, output=out, error=error)\n        return {"task": task, "result": last_output, "transcript": transcript}\n''',

    "tools.py": r'''\nfrom __future__ import annotations\nimport json\nimport os\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Callable, Optional\nimport urllib.request\n\nclass ToolError(RuntimeError):\n    pass\n\n@dataclass\nclass Tool:\n    name: str\n    run: Callable[..., Any]\n\nclass ToolRegistry:\n    """Registry of simple, auditable tools."""\n\n    def __init__(self) -> None:\n        self._tools: Dict[str, Tool] = {}\n        self.register("python", self._python_exec)\n        self.register("http", self._http_simple)\n        self.register("json", self._json_tool)\n\n    def register(self, name: str, func: Callable[..., Any]) -> None:\n        self._tools[name] = Tool(name, func)\n\n    def use(self, name: str, step: str, **kwargs: Any) -> Any:\n        if name not in self._tools:\n            raise ToolError(f"unknown tool: {name}")\n        try:\n            return self._tools[name].run(step=step, **kwargs)\n        except ToolError:\n            raise\n        except Exception as e:\n            raise ToolError(str(e))\n\n    def _python_exec(self, step: str, timeout: int = 3, context: Optional[Any] = None) -> str:\n        code = step\n        s = step.lower()\n        if "python" in s:\n            code = step.split(step[s.find("python") :].split()[0], 1)[1].strip() or step\n        wrapped = textwrap.dedent(\n            f"""\nimport math, json, sys\n_ctx = {json.dumps(context) if context is not None else 'None'}\n{code}\nprint(locals().get('result') if 'result' in locals() else '')\n"""\n        )\n        with tempfile.TemporaryDirectory() as td:\n            path = os.path.join(td, "prog.py")\n            with open(path, "w", encoding="utf-8") as f:\n                f.write(wrapped)\n            try:\n                proc = subprocess.run([sys.executable, path], capture_output=True, text=True, timeout=timeout)\n            except subprocess.TimeoutExpired:\n                raise ToolError("python timeout")\n            if proc.returncode != 0:\n                raise ToolError(proc.stderr.strip() or "python error")\n            return proc.stdout.strip()\n\n    def _http_simple(self, step: str, method: str = "GET", timeout: int = 10, context: Optional[Any] = None) -> str:\n        tokens = step.split()\n        url = next((t for t in tokens if t.startswith("http://") or t.startswith("https://")), None)\n        if not url:\n            raise ToolError("no url found")\n        req = urllib.request.Request(url=url, method=method.upper())\n        try:\n            with urllib.request.urlopen(req, timeout=timeout) as resp:\n                body = resp.read()[:100_000]\n                return body.decode("utf-8", errors="ignore")\n        except Exception as e:\n            raise ToolError(f"http error: {e}")\n\n    def _json_tool(self, step: str, context: Optional[Any] = None) -> str:\n        try:\n            payload = context if isinstance(context, str) and context.strip().startswith("{") else step\n            data = json.loads(payload)\n            return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ToolError(f"json error: {e}")\n''',

    "memory.py": r'''\nfrom __future__ import annotations\nimport json\nimport os\nimport time\nfrom typing import Any, Dict, List\n\nclass Memory:\n    """Append-only JSONL memory."""\n\n    def __init__(self, path: str = "memory.jsonl") -> None:\n        self.path = path\n        if not os.path.exists(self.path):\n            open(self.path, "a", encoding="utf-8").close()\n\n    def store(self, **record: Any) -> None:\n        rec = {"ts": time.time(), **record}\n        with open(self.path, "a", encoding="utf-8") as f:\n            f.write(json.dumps(rec, ensure_ascii=False) + "\n")\n\n    def all(self) -> List[Dict[str, Any]]:\n        out: List[Dict[str, Any]] = []\n        with open(self.path, "r", encoding="utf-8") as f:\n            for line in f:\n                line = line.strip()\n                if not line:\n                    continue\n                out.append(json.loads(line))\n        return out\n''',

    "learning.py": r'''\nfrom __future__ import annotations\nimport math\nfrom typing import Dict\n\nclass UCB1:\n    """Per-arm UCB1 bandit."""\n\n    def __init__(self) -> None:\n        self.counts: Dict[str, int] = {}\n        self.rewards: Dict[str, float] = {}\n        self.total: int = 0\n\n    def choose(self, arm: str) -> float:\n        self.total += 1\n        self.counts.setdefault(arm, 0)\n        self.rewards.setdefault(arm, 0.0)\n        c = self.counts[arm]\n        if c == 0:\n            self.counts[arm] = 1\n            return float("inf")\n        bonus = math.sqrt(2.0 * math.log(self.total) / c)\n        return self.rewards[arm] / c + bonus\n\n    def update(self, arm: str, success: bool) -> None:\n        self.counts[arm] = self.counts.get(arm, 0) + 1\n        self.rewards[arm] = self.rewards.get(arm, 0.0) + (1.0 if success else 0.0)\n''',

    "upgrade.py": r'''\nfrom __future__ import annotations\nimport os\nfrom typing import Any, Dict, Optional\nimport yaml\n\nclass SkillsReloader:\n    """YAML skills hot-reloader."""\n\n    def __init__(self, path: str) -> None:\n        self.path = path\n        self._mtime: float = 0.0\n        self._doc: Dict[str, Any] = {"rules": []}\n        self.refresh(force=True)\n\n    def refresh(self, force: bool = False) -> None:\n        try:\n            m = os.path.getmtime(self.path)\n        except OSError:\n            return\n        if force or m > self._mtime:\n            with open(self.path, "r", encoding="utf-8") as f:\n                self._doc = yaml.safe_load(f) or {"rules": []}\n            self._mtime = m\n\n    def match(self, text: str) -> Optional[Dict[str, Any]]:\n        t = text.lower()\n        for rule in self._doc.get("rules", []):\n            terms = [str(x).lower() for x in rule.get("if_contains", [])]\n            if any(term in t for term in terms):\n                return rule\n        return None\n''',

    "health.py": r'''\nfrom __future__ import annotations\nimport time\n\nclass CircuitBreaker:\n    """Simple circuit breaker."""\n\n    def __init__(self, window: int = 5, cool: float = 5.0) -> None:\n        self.window = window\n        self.cool = cool\n        self.fail = 0\n        self.open = False\n        self.opened_at = 0.0\n\n    def record(self, success: bool) -> None:\n        if self.open and (time.time() - self.opened_at) > self.cool:\n            self.open = False\n            self.fail = 0\n        if success:\n            self.fail = 0\n            return\n        self.fail += 1\n        if self.fail >= self.window:\n            self.open = True\n            self.opened_at = time.time()\n''',

    # Scaling utilities required by server.py\n    "scaling.py": r'''\nfrom __future__ import annotations\nfrom typing import Any, Dict, List\nfrom agent import Agent\nfrom memory import Memory\nfrom tools import ToolRegistry\nfrom upgrade import SkillsReloader\n\ndef build_agent(bot: str, skills_path: str) -> Agent:\n    mem = Memory(path=f"memory_{bot}.jsonl")\n    tools = ToolRegistry()\n    skills = SkillsReloader(skills_path)\n    return Agent(name=bot, memory=mem, tools=tools, skills=skills)\n''',

    # FastAPI server\n    "server.py": r'''\nfrom __future__ import annotations\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport yaml\nfrom scaling import build_agent\n\napp = FastAPI(title="OmniScope API")\n\nwith open("bots.yaml", "r", encoding="utf-8") as f:\n    BOTS = yaml.safe_load(f)["bots"]\n\nclass SolveReq(BaseModel):\n    bot: str\n    task: str\n\n@app.post("/solve")\ndef solve(req: SolveReq):\n    bot_cfg = BOTS.get(req.bot)\n    if not bot_cfg:\n        raise HTTPException(status_code=404, detail="unknown bot")\n    agent = build_agent(req.bot, bot_cfg["skills_path"])\n    return agent.solve(req.task)\n''',

    "Dockerfile": r'''\nFROM python:3.10-slim\nWORKDIR /app\nCOPY requirements.txt ./\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY . .\nENV PORT=8080\nCMD ["uvicorn", "server:app", "--host", "0.0.0.0", "--port", "8080"]\n''',

    # Firebase wrapper\n    "firebase.json": r'''\n{\n  "functions": {"source": "functions"},\n  "hosting": {\n    "public": "web",\n    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],\n    "rewrites": [{"source": "/api/solve", "function": "solve"}]\n  }\n}\n''',

    ".firebaserc": r'''\n{\n  "projects": {"default": "your-project-id"}\n}\n''',

    "functions/package.json": r'''\n{\n  "name": "omniscope-functions",\n  "private": true,\n  "type": "module",\n  "engines": {"node": "18"},\n  "scripts": {\n    "build": "tsc -p tsconfig.json",\n    "deploy": "firebase deploy --only functions"\n  },\n  "dependencies": {\n    "firebase-admin": "^11.10.1",\n    "firebase-functions": "^4.4.1",\n    "cross-fetch": "^3.1.8"\n  },\n  "devDependencies": {"typescript": "^5.4.0"}\n}\n''',

    "functions/tsconfig.json": r'''\n{\n  "compilerOptions": {\n    "target": "ES2020",\n    "module": "ES2020",\n    "moduleResolution": "Node",\n    "outDir": "lib",\n    "rootDir": "src",\n    "esModuleInterop": true,\n    "strict": true\n  },\n  "include": ["src"]\n}\n''',

    "functions/src/index.ts": r'''\nimport * as functions from "firebase-functions";\nimport fetch from "cross-fetch";\n\nexport const solve = functions.https.onRequest(async (req, res) => {\n  res.set("Access-Control-Allow-Origin", "*");\n  res.set("Access-Control-Allow-Headers", "Content-Type");\n  if (req.method === "OPTIONS") return res.status(204).send("");\n\n  try {\n    const body = typeof req.body === "string" ? JSON.parse(req.body) : req.body;\n    const { bot, task } = body || {};\n    if (!bot || !task) return res.status(400).json({ error: "bot and task required" });\n\n    const runUrl = (functions.config()?.run?.url as string) || process.env.RUN_URL || "http://localhost:8080";\n    const r = await fetch(`${runUrl}/solve`, {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify({ bot, task })\n    });\n    const data = await r.json();\n    return res.status(r.status).json(data);\n  } catch (e: any) {\n    return res.status(500).json({ error: String(e) });\n  }\n});\n''',

    # Minimal branding page\n    "web/index.html": r'''\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>OmniScope Bots</title>\n    <script src="https://cdn.tailwindcss.com"></script>\n  </head>\n  <body class="bg-slate-950 text-slate-100 min-h-screen">\n    <main class="max-w-5xl mx-auto p-6 space-y-6">\n      <h1 class="text-3xl font-bold">OmniScope Bots</h1>\n      <p class="text-slate-400">Styled after your references. Use the button to call Firebase Function → Cloud Run → Python agent.</p>\n      <div class="grid md:grid-cols-3 gap-6">\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Alofa</h3><p class="text-slate-400">Athletic tactician</p></div>\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Gookie</h3><p class="text-slate-400">Curious companion</p></div>\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Skiv</h3><p class="text-slate-400">Armored solver</p></div>\n      </div>\n      <div class="flex gap-2">\n        <input id="task" class="flex-1 p-3 rounded bg-slate-800" placeholder="e.g. fetch https://httpbin.org/json; json" />\n        <button id="go" class="px-4 py-3 rounded bg-blue-600">Run</button>\n      </div>\n      <pre id="out" class="bg-slate-900 p-4 rounded overflow-auto text-sm"></pre>\n    </main>\n    <script>\n      document.getElementById('go').onclick = async () => {\n        const task = (document.getElementById('task')).value;\n        const res = await fetch('/api/solve', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({bot:'scouty', task})});\n        const data = await res.json();\n        document.getElementById('out').textContent = JSON.stringify(data, null, 2);\n      };\n    </script>\n  </body>\n</html>\n''',

    # GitHub Actions: PyPI publish via Trusted Publishing\n    ".github/workflows/pypi-publish.yml": r'''\nname: Publish to PyPI\n\non:\n  release:\n    types: [published]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: pypi-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  build:\n    name: Build distributions\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n      - name: Install build backend\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install build\n      - name: Build sdist and wheel\n        run: python -m build\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-distributions\n          path: dist/*\n          if-no-files-found: error\n\n  publish:\n    name: Publish to PyPI\n    runs-on: ubuntu-latest\n    needs: build\n    permissions:\n      id-token: write   # required for Trusted Publishing\n      contents: read\n    environment:\n      name: pypi\n      # url: https://pypi.org/project/YOURPROJECT/\n    steps:\n      - name: Download artifacts\n        uses: actions/download-artifact@v4\n        with:\n          name: python-distributions\n          path: dist/\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n        with:\n          packages-dir: dist/\n''',

    # GitHub Actions: Cloud Run deploy\n    ".github/workflows/cloudrun-deploy.yml": r'''\nname: Deploy to Cloud Run\n\non:\n  push:\n    branches: ["main"]\n    paths:\n      - '**/*.py'\n      - 'Dockerfile'\n      - 'requirements.txt'\n      - 'bots.yaml'\n      - '.github/workflows/cloudrun-deploy.yml'\n  workflow_dispatch: {}\n\npermissions:\n  contents: read\n  id-token: write   # Workload Identity Federation\n\nconcurrency:\n  group: cloudrun-${{ github.ref }}\n  cancel-in-progress: false\n\nenv:\n  SERVICE_NAME: ${{ vars.CLOUD_RUN_SERVICE }}\n  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}\n  REGION: ${{ secrets.GCP_REGION }}\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - id: auth\n        uses: google-github-actions/auth@v2\n        with:\n          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}\n          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n\n      - uses: google-github-actions/setup-gcloud@v2\n        with:\n          project_id: ${{ env.PROJECT_ID }}\n\n      - name: Resolve defaults\n        run: |\n          REGION=${REGION:-us-central1}\n          SERVICE_NAME=${SERVICE_NAME:-omniscope}\n          echo "REGION=$REGION" >> $GITHUB_ENV\n          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV\n\n      - name: Build and push image with Cloud Build\n        run: |\n          IMAGE="gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${GITHUB_SHA}"\n          gcloud builds submit --tag "$IMAGE" .\n          echo "IMAGE=$IMAGE" >> $GITHUB_ENV\n\n      - name: Deploy to Cloud Run\n        run: |\n          gcloud run deploy "$SERVICE_NAME" \n            --image "$IMAGE" \n            --region "$REGION" \n            --platform managed \n            --allow-unauthenticated\n\n      - name: Output Service URL\n        run: |\n          gcloud run services describe "$SERVICE_NAME" --region "$REGION" --format='value(status.url)'\n''',

    # Tests\n    "tests/test_agent.py": r'''\nfrom scaling import build_agent\n\ndef test_http_rule():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("fetch https://httpbin.org/json and json parse")\n    assert out["transcript"], "no transcript"\n\ndef test_python_tool_simple_math():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("python result = 2 + 3")\n    assert out["result"].strip() == "5"\n\ndef test_json_tool_with_context():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("python result = '{\"a\": 1}'; json")\n    assert '"a": 1' in out["result"]\n''',

    "tests/test_plugins.py": r'''\nfrom scaling import build_agent\n\ndef test_math_plugin_basic():\n    a = build_agent("scouty", "skills/default.yaml")\n    # math tool not registered by default, ensure graceful fallback\n    out = a.solve("calc 3*7")\n    assert out["transcript"], "no transcript"\n''',

    "tests/test_planner.py": r'''\nfrom scaling import build_agent\n\ndef test_semicolon_step_split():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("python result = '{\"x\":1}'; json")\n    assert '"x": 1' in out["result"]\n''',

    "tests/test_routing.py": r'''\nfrom scaling import build_agent\n\ndef test_default_route_python_when_unknown():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("compute 1+1")\n    assert out["transcript"], "no transcript"\n''',

    "tests/test_skills_yaml.py": r'''\nimport yaml\n\ndef test_skills_yaml_parses():\n    with open("skills/default.yaml", "r", encoding="utf-8") as f:\n        doc = yaml.safe_load(f)\n    assert isinstance(doc, dict) and "rules" in doc and isinstance(doc["rules"], list) and len(doc["rules"]) > 0\n''',

    "examples/tasks.txt": r'''\nfetch https://httpbin.org/json and json parse\npython result = 2 + 2\njson {"a": 1}\n''',

    # Minimal branding page
    "web/index.html": r'''\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>OmniScope Bots</title>\n    <script src="https://cdn.tailwindcss.com"></script>\n  </head>\n  <body class="bg-slate-950 text-slate-100 min-h-screen">\n    <main class="max-w-5xl mx-auto p-6 space-y-6">\n      <h1 class="text-3xl font-bold">OmniScope Bots</h1>\n      <p class="text-slate-400">Styled after your references. Use the button to call Firebase Function → Cloud Run → Python agent.</p>\n      <div class="grid md:grid-cols-3 gap-6">\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Alofa</h3><p class="text-slate-400">Athletic tactician</p></div>\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Gookie</h3><p class="text-slate-400">Curious companion</p></div>\n        <div class="p-5 rounded-2xl bg-slate-900"><h3 class="font-semibold">Skiv</h3><p class="text-slate-400">Armored solver</p></div>\n      </div>\n      <div class="flex gap-2">\n        <input id="task" class="flex-1 p-3 rounded bg-slate-800" placeholder="e.g. fetch https://httpbin.org/json; json" />\n        <button id="go" class="px-4 py-3 rounded bg-blue-600">Run</button>\n      </div>\n      <pre id="out" class="bg-slate-900 p-4 rounded overflow-auto text-sm"></pre>\n    </main>\n    <script>\n      document.getElementById('go').onclick = async () => {\n        const task = (document.getElementById('task')).value;\n        const res = await fetch('/api/solve', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({bot:'scouty', task})});\n        const data = await res.json();\n        document.getElementById('out').textContent = JSON.stringify(data, null, 2);\n      };\n    </script>\n  </body>\n</html>\n''',

    # GitHub Actions: PyPI publish via Trusted Publishing
    ".github/workflows/pypi-publish.yml": r'''\nname: Publish to PyPI\n\non:\n  release:\n    types: [published]\n\npermissions:\n  contents: read\n\nconcurrency:\n  group: pypi-${{ github.ref }}\n  cancel-in-progress: false\n\njobs:\n  build:\n    name: Build distributions\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n          cache: 'pip'\n      - name: Install build backend\n        run: |\n          python -m pip install --upgrade pip\n          python -m pip install build\n      - name: Build sdist and wheel\n        run: python -m build\n      - name: Upload artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-distributions\n          path: dist/*\n          if-no-files-found: error\n\n  publish:\n    name: Publish to PyPI\n    runs-on: ubuntu-latest\n    needs: build\n    permissions:\n      id-token: write   # required for Trusted Publishing\n      contents: read\n    environment:\n      name: pypi\n      # url: https://pypi.org/project/YOURPROJECT/\n    steps:\n      - name: Download artifacts\n        uses: actions/download-artifact@v4\n        with:\n          name: python-distributions\n          path: dist/\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n        with:\n          packages-dir: dist/\n''',

    # GitHub Actions: Cloud Run deploy
    ".github/workflows/cloudrun-deploy.yml": r'''\nname: Deploy to Cloud Run\n\non:\n  push:\n    branches: ["main"]\n    paths:\n      - '**/*.py'\n      - 'Dockerfile'\n      - 'requirements.txt'\n      - 'bots.yaml'\n      - '.github/workflows/cloudrun-deploy.yml'\n  workflow_dispatch: {}\n\npermissions:\n  contents: read\n  id-token: write   # Workload Identity Federation\n\nconcurrency:\n  group: cloudrun-${{ github.ref }}\n  cancel-in-progress: false\n\nenv:\n  SERVICE_NAME: ${{ vars.CLOUD_RUN_SERVICE }}\n  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}\n  REGION: ${{ secrets.GCP_REGION }}\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - id: auth\n        uses: google-github-actions/auth@v2\n        with:\n          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}\n          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}\n\n      - uses: google-github-actions/setup-gcloud@v2\n        with:\n          project_id: ${{ env.PROJECT_ID }}\n\n      - name: Resolve defaults\n        run: |\n          REGION=${REGION:-us-central1}\n          SERVICE_NAME=${SERVICE_NAME:-omniscope}\n          echo "REGION=$REGION" >> $GITHUB_ENV\n          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV\n\n      - name: Build and push image with Cloud Build\n        run: |\n          IMAGE="gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${GITHUB_SHA}"\n          gcloud builds submit --tag "$IMAGE" .\n          echo "IMAGE=$IMAGE" >> $GITHUB_ENV\n\n      - name: Deploy to Cloud Run\n        run: |\n          gcloud run deploy "$SERVICE_NAME" \n            --image "$IMAGE" \n            --region "$REGION" \n            --platform managed \n            --allow-unauthenticated\n\n      - name: Output Service URL\n        run: |\n          gcloud run services describe "$SERVICE_NAME" --region "$REGION" --format='value(status.url)'\n''',

    # Tests
    "tests/test_agent.py": r'''\nfrom scaling import build_agent\n\ndef test_http_rule():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("fetch https://httpbin.org/json and json parse")\n    assert out["transcript"], "no transcript"\n\ndef test_python_tool_simple_math():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("python result = 2 + 3")\n    assert out["result"].strip() == "5"\n\ndef test_json_tool_with_context():\n    a = build_agent("scouty", "skills/default.yaml")\n    out = a.solve("python result = '{\"a\": 1}'; json")\n    assert '"a": 1' in out["result"]\n''',
}

def write_files(base: str = ".") -> None:
    import subprocess
    
    # Check if we're in a git repository and if there are uncommitted changes
    try:
        result = subprocess.run(['git', 'status', '--porcelain'], 
                              capture_output=True, text=True, cwd=base)
        if result.returncode == 0 and result.stdout.strip():
            # There are uncommitted changes
            print("Warning: Uncommitted changes detected.")
            print("Stashing changes before updating files...")
            stash_result = subprocess.run(['git', 'stash', 'push', '-m', 
                                         'Auto-stash before repo_pack.py --init'], 
                                        capture_output=True, text=True, cwd=base)
            if stash_result.returncode != 0:
                print(f"Failed to stash changes: {stash_result.stderr}")
                print("Proceeding anyway...")
    except FileNotFoundError:
        # Git not available, proceed without stashing
        pass
    except Exception as e:
        print(f"Error checking git status: {e}")
        print("Proceeding without stashing...")
    
    for rel, content in FILES.items():
        path = Path(base) / rel
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w", encoding="utf-8") as f:
            f.write(content.strip() + ("\n" if not content.endswith("\n") else ""))

def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--init", action="store_true", help="write repo files to disk")
    args = ap.parse_args()
    if args.init:
        write_files()
        print("repo files written. next: `uvicorn server:app --reload --port 8080`. For Firebase see README.")
    else:
        print("no action. use --init to write files.")

if __name__ == "__main__":
    main()