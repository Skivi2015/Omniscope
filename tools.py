\nfrom __future__ import annotations\nimport json\nimport os\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Callable, Optional\nimport urllib.request\n\nclass ToolError(RuntimeError):\n    pass\n\n@dataclass\nclass Tool:\n    name: str\n    run: Callable[..., Any]\n\nclass ToolRegistry:\n    """Registry of simple, auditable tools."""\n\n    def __init__(self) -> None:\n        self._tools: Dict[str, Tool] = {}\n        self.register("python", self._python_exec)\n        self.register("http", self._http_simple)\n        self.register("json", self._json_tool)\n\n    def register(self, name: str, func: Callable[..., Any]) -> None:\n        self._tools[name] = Tool(name, func)\n\n    def use(self, name: str, step: str, **kwargs: Any) -> Any:\n        if name not in self._tools:\n            raise ToolError(f"unknown tool: {name}")\n        try:\n            return self._tools[name].run(step=step, **kwargs)\n        except ToolError:\n            raise\n        except Exception as e:\n            raise ToolError(str(e))\n\n    def _python_exec(self, step: str, timeout: int = 3, context: Optional[Any] = None) -> str:\n        code = step\n        s = step.lower()\n        if "python" in s:\n            code = step.split(step[s.find("python") :].split()[0], 1)[1].strip() or step\n        wrapped = textwrap.dedent(\n            f"""\nimport math, json, sys\n_ctx = {json.dumps(context) if context is not None else 'None'}\n{code}\nprint(locals().get('result') if 'result' in locals() else '')\n"""\n        )\n        with tempfile.TemporaryDirectory() as td:\n            path = os.path.join(td, "prog.py")\n            with open(path, "w", encoding="utf-8") as f:\n                f.write(wrapped)\n            try:\n                proc = subprocess.run([sys.executable, path], capture_output=True, text=True, timeout=timeout)\n            except subprocess.TimeoutExpired:\n                raise ToolError("python timeout")\n            if proc.returncode != 0:\n                raise ToolError(proc.stderr.strip() or "python error")\n            return proc.stdout.strip()\n\n    def _http_simple(self, step: str, method: str = "GET", timeout: int = 10, context: Optional[Any] = None) -> str:\n        tokens = step.split()\n        url = next((t for t in tokens if t.startswith("http://") or t.startswith("https://")), None)\n        if not url:\n            raise ToolError("no url found")\n        req = urllib.request.Request(url=url, method=method.upper())\n        try:\n            with urllib.request.urlopen(req, timeout=timeout) as resp:\n                body = resp.read()[:100_000]\n                return body.decode("utf-8", errors="ignore")\n        except Exception as e:\n            raise ToolError(f"http error: {e}")\n\n    def _json_tool(self, step: str, context: Optional[Any] = None) -> str:\n        try:\n            payload = context if isinstance(context, str) and context.strip().startswith("{") else step\n            data = json.loads(payload)\n            return json.dumps(data, indent=2, ensure_ascii=False)\n        except Exception as e:\n            raise ToolError(f"json error: {e}")\n
